<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Performance measurement</title>
    <script>
let data;

function compute() {
  const numberOfLoops = document.querySelector('#loopCount').value;
  const eventSource = new EventSource(`http://localhost:8080/compute/${numberOfLoops}`);
  const progress = document.querySelector('.progress');
  data = [];

  eventSource.addEventListener('progress', (event) => {
    const chunk = JSON.parse(event.data);
    data.push(chunk);
    progress.innerHTML = `sample count: ${chunk.sampleCount}, cycles: ${chunk.cycles}, time spent: ${chunk.timeSpent}`;
  });

  eventSource.addEventListener('done', () => {
    eventSource.close();
    progress.innerHTML = 'Analyzing data...';
    setTimeout(analyze, 0);
  });
}

class TimeBucket {
  #count = 0;
  #total = 0;
  #ranges = [];
  #max = 0;

  add (duration) {
    ++this.#count;
    ++this.#total;

    const index = duration / 100;
    if (isNaN(index)) {
      debugger;
    }
    if (!this.#ranges[index]) {
      this.#ranges[index] = 1;
    } else {
      this.#max = Math.max(++this.#ranges[index], this.#max);
    }
  }

  clean () {
    const threshold = Math.ceil(this.#count / 100);
    for (let index = 0; index < this.#ranges.length; ++index) {
      if (this.#ranges[index] < threshold) {
        delete this.#ranges[index];
      }
    }
  }

  ratio (index) {
    return (this.#ranges[index] ?? 0)/ this.#max;
  }
}

const buckets = {};

function analyze() {
  for (const { measures } of data) {
    for (const measure of measures.split(/[,|]/)) {
      const [,type, name, operatorState, baseDuration] = measure.match(/(\w)(?::([^=@]+))?(?:@(-?\d+))?=(\d+)/)
      const duration = baseDuration * 100
      if (type === 'p') {
        if (!buckets['-parser-']) {
          buckets['-parser-'] = new TimeBucket();
        }
        buckets['-parser-'].add(duration);
      } else if (type === 'o') {
        if (!buckets[`-${name}-`]) {
          buckets[`-${name}-`] = new TimeBucket();
        }
        buckets[`-${name}-`].add(duration);
      }
    }
  }

  const keys = Object.keys(buckets).sort();
  const tbody = document.querySelector('tbody');
  tbody.innerHTML = '';
  for (const key of keys) {
    const bucket = buckets[key];
    bucket.clean();
    const row = tbody.appendChild(document.createElement('tr'));
    row.appendChild(document.createElement('td')).innerHTML = key;
    const bars = [];
    const colors = ['#0000FF', '#00FFFF', '#00FF00', '#FFFF00', '#FF7F00', '#FF0000'];
    for (let index = 0; index < 100; ++index) {
      const ratio = bucket.ratio(index);
      if (ratio > 0) {
        const color = ratio === 1? colors.at(-1) : colors[Math.floor(ratio * colors.length)];
        bars.push(`<rect x="${index}" y="0" width="1" height="20" fill="${color}"/>`)
      }
    }
    row.appendChild(document.createElement('td')).innerHTML = `<svg width="100" height="20" version="1.1" xmlns="http://www.w3.org/2000/svg">${bars.join('')}</svg>`;
  }

  document.querySelector('.progress').innerHTML = '';
}

/*

const intructions = Object.keys(measurements).sort();
const statistics = {};
for (const instruction of intructions) {
  const durations = measurements[instruction];
  const totalDuration = durations.reduce((total, duration) => duration + total);
  const mean = Math.floor(totalDuration / durations.length);
  const variance = Math.floor(
    Math.sqrt(durations.reduce((total, duration) => total + (mean - duration) ** 2, 0) / (durations.length - 1))
  );
  const halfPercentile = Math.floor(
    (100 * durations.reduce((total, duration) => total + (2 * duration <= mean ? 1 : 0), 0)) / durations.length
  );
  const meanPercentile = Math.floor(
    (100 * durations.reduce((total, duration) => total + (duration <= mean ? 1 : 0), 0)) / durations.length
  );
  const twicePercentile = Math.floor(
    (100 * durations.reduce((total, duration) => total + (duration >= 2 * mean ? 1 : 0), 0)) / durations.length
  );
  statistics[instruction] = {
    count: durations.length,
    't (ns)': mean, // > 2 * globalMean ? `${red}${mean}${white}` : `${yellow}${mean}${white}`,
    Δ: variance,
    '≤t%': meanPercentile,
    '≤½t%': halfPercentile,
    '≥2t%': twicePercentile
  };
  measurements[instruction] = {
    durations,
    mean,
    variance,
    meanPercentile,
    twicePercentile
  };
}
*/

    </script>
  </head>
  <body>
    <h1>Performance measurement</h1>
    <label for="loopCount">Select number of loops:</label>
    <select id="loopCount">
        <option value="1">1</option>
        <option value="10">10</option>
        <option value="100">100</option>
        <option value="500">500</option>
        <option value="1000">1000</option>
    </select>
    <button onclick="compute()">Compute</button>
    <div class="progress"></div>
    <table>
      <thead>
        <tr>
          <th>instruction</th>
          <th>bucket</th>
        </tr>
      </thead>
      <tbody>
      </tbody>
    </table>
  </body>
</html>