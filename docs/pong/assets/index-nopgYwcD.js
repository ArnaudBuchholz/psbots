var dt=Object.defineProperty;var ht=(s,e,t)=>e in s?dt(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t;var d=(s,e,t)=>ht(s,typeof e!="symbol"?e+"":e,t);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))n(i);new MutationObserver(i=>{for(const a of i)if(a.type==="childList")for(const o of a.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&n(o)}).observe(document,{childList:!0,subtree:!0});function t(i){const a={};return i.integrity&&(a.integrity=i.integrity),i.referrerPolicy&&(a.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?a.credentials="include":i.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function n(i){if(i.ep)return;i.ep=!0;const a=t(i);fetch(i.href,a)}})();const I="system",Ze="user";function*ft(s){const{length:e}=s;for(let t=0;t<e;++t)yield s.at(t)}var r;(function(s){s.null="null",s.boolean="boolean",s.integer="integer",s.string="string",s.name="name",s.mark="mark",s.operator="operator",s.array="array",s.dictionary="dictionary"})(r||(r={}));function*be(s,e=0,t){const n=/%[^\n]*|(?:"([^"]*)")|\s|((?:-|\+)?\d+)|(\[|\]|{|}|<<|>>|«|»|[^[\]{}<>«»\s]+)/g;n.lastIndex=e;let i=n.exec(s);for(;i!==null;){const[a,o,c,p]=i,h={isReadOnly:!0};t!==void 0&&(h.debugSource={source:s,filename:t,pos:i.index,length:a.length}),o!==void 0?yield{...h,type:r.string,isExecutable:!1,string:o}:c!==void 0?yield{...h,type:r.integer,isExecutable:!1,integer:parseInt(c,10)}:p!==void 0&&(p.length>1&&p.startsWith("/")?yield{...h,type:r.name,isExecutable:!1,name:p.substring(1)}:yield{...h,type:r.name,isExecutable:!0,name:p}),i=n.exec(s)}}const ke={type:r.mark,isReadOnly:!0,isExecutable:!1},y={type:r.null,isReadOnly:!0,isExecutable:!1};class Ie extends Error{constructor(e,t){super(e),this.name="AssertionFailed",this.cause=t}}function u(s,e,t){if(typeof s!="boolean"){if(!s.success)throw new Ie("Unexpected failed result",s.exception)}else if(!s)throw new Ie(e??"assertion failed",t)}function se(s,e){if(s.type!==r.integer)return{success:!1,exception:"typeCheck"};const{integer:t}=s;return t<0||t>=e?{success:!1,exception:"rangeCheck"}:{success:!0,value:t}}function yt(s){return typeof s=="object"&&s!==null}const mt={[r.string]:{isReadOnly:!0},[r.operator]:{isReadOnly:!0,isExecutable:!0}};function gt(s){const e=["isReadOnly","isExecutable"],t=mt[s.type];for(const n of e){const i=t&&t[n];if(i!==void 0){if(s[n]!==i)return!0}else if(typeof s[n]!="boolean")return!0}return!1}function _t({isReadOnly:s,isExecutable:e},{isReadOnly:t,isExecutable:n}={}){return!(t!==void 0&&s!==t||n!==void 0&&e!==n)}function bt(s,e,t,n){return yt(e)&&e.type===s&&!gt(e)&&_t(e,t)&&n(e)}function kt(s){return typeof s=="number"&&s%1===0}const Ae=(s,e)=>typeof s=="function"&&s.length===e,xt=s=>kt(s)&&s>=0;function vt(s,e){return bt(r.array,s,e,({isReadOnly:t,array:n})=>n!==void 0&&xt(n.length)&&Ae(n.at,1)&&(t||Ae(n.set,2)))}function oe(s){let e=0;for(;e<s.length&&s.at(e).type!==r.mark;)++e;return e===s.length?{success:!1,exception:"unmatchedMark"}:{success:!0,value:e}}const A=Number.POSITIVE_INFINITY,m=0,R=-1,C=Number.NEGATIVE_INFINITY;var F;(function(s){s[s.constant=0]="constant",s[s.implementation=1]="implementation"})(F||(F={}));const St="␀",ee="▻",$="◅";function Rt(s,e){let t=1,n=0,i=s.indexOf(`
`);for(;i!==-1&&n+e>i;)++i,e-=i-n,n=i,++t,i=s.indexOf(`
`,n);return{line:t,col:e+1}}function Ot(s){const e=s.split(/(\\|\/)/).filter(t=>t.trim());return e.length<3?s:"…"+e.splice(-2).join("")}function wt(s,e,t){let n;if(e!==void 0?n=`${s}@${e}`:n=s,t<1||n.length<=t)return n;let i="";if(e!==void 0){if(i=`@${Ot(e)}`,n=`${s}${i}`,n.length<=t)return n;t<i.length?i="":t-=i.length}const a=s.indexOf(ee),o=s.indexOf($,a+1),c=o-a+1;if(a>-1&&o>-1&&c>0)if(t>c){let p=a-Math.ceil((t-c)/2);p+t>s.length&&(p=s.length-t+1),p>0&&(s="…"+s.substring(p))}else s="…"+s.substring(a-1);return s.length>t&&(s=s.substring(0,t-1)+"…"),i?`${s}${i}`:s}function L(s,e,{includeDebugSource:t=!1,maxWidth:n=0}){let i;if(e!==void 0&&t){const{filename:a,source:o}=e,{line:c,col:p}=Rt(o,e.pos);i=`${a}:${c}:${p}`}return wt(s,i,n)}const Et={[r.null]:({debugSource:s},e)=>L(St,s,e),[r.boolean]:({isSet:s,debugSource:e},t)=>L(s?"true":"false",e,t),[r.integer]:({integer:s,debugSource:e},t)=>L(s.toString(),e,t),[r.string]:({isExecutable:s,string:e,debugSource:t},n)=>{var a;let i;if(s){const{operatorState:o}=n;if(o!==void 0&&o>=m){const[c]=be(e,o,"toString"),p=(a=c==null?void 0:c.debugSource)==null?void 0:a.length;p!==void 0&&(i=e.substring(0,o)+ee+e.substring(o,o+p)+$+e.substring(o+p))}i||(i=e)}else i=JSON.stringify(e);return L(i,t,n)},[r.name]:({isExecutable:s,name:e,debugSource:t},n)=>{let i=e.replace(/ /g,"␣");return s||(i=`/${i}`),L(i,t,n)},[r.mark]:({debugSource:s},e)=>L("--mark--",s,e),[r.operator]:({operator:s,debugSource:e},t)=>{let n=`-${s.name}-`;const{operatorState:i}=t;return i!==void 0&&i!==A&&(i>m?n+=`${ee}${i==null?void 0:i.toString()}`:i===R?n+=$:i===C?n+=`${$}${$}`:i<R&&(n+=`${$}${i==null?void 0:i.toString()}`)),L(n,e,t)},[r.array]:({isExecutable:s,array:e,debugSource:t},n)=>{const i=[];s?i.push("{"):i.push("[");const{length:a}=e,{operatorState:o}=n;for(let c=0;c<a;++c){const p=e.at(c),h=Et[p.type](p,Object.assign({},n,{includeDebugSource:!1,maxWidth:0,operatorState:A}));s&&o===c?i.push(ee+h+$):i.push(h)}return s?i.push("}"):i.push("]"),L(i.join(" "),t,n)},[r.dictionary]:({dictionary:s,isReadOnly:e,debugSource:t},n)=>{let a=s.names.length.toString().toString();return e||(a+="/∞"),L(`--dictionary(${a})--`,t,n)}};function b(s){return{type:r.boolean,isExecutable:!1,isReadOnly:!0,isSet:s}}function S(s){return s%1!==0||s<Number.MIN_SAFE_INTEGER||s>Number.MAX_SAFE_INTEGER?{success:!1,exception:"undefinedResult"}:{success:!0,value:{type:r.integer,isExecutable:!1,isReadOnly:!0,integer:s}}}function G(s,{isExecutable:e=!1,tracker:t}={}){return t?{type:r.string,isExecutable:e,isReadOnly:!0,string:s,tracker:t}:{type:r.string,isExecutable:e,isReadOnly:!0,string:s}}function Qe(s,{isExecutable:e=!1,tracker:t}={}){return t?{type:r.name,isExecutable:e,isReadOnly:!0,name:s,tracker:t}:{type:r.name,isExecutable:e,isReadOnly:!0,name:s}}const Tt={[r.null]:()=>null,[r.boolean]:s=>s.isSet,[r.integer]:s=>s.integer,[r.string]:s=>s.string,[r.name]:s=>s.name,[r.mark]:()=>null,[r.operator]:s=>s.operator,[r.array]:s=>s.array,[r.dictionary]:s=>s.dictionary};function It(s){return Tt[s.type](s)}function j(...s){return s.map(e=>It(e))}const q={};function l(s,e){var i;u(!q[s.name],`Operator ${s.name} is not defined`),Object.freeze(s);const t={type:F.implementation,name:s.name,typeCheck:(i=s.signature)==null?void 0:i.input,implementation:e},n={type:r.operator,isExecutable:!0,isReadOnly:!0,operator:t};return q[s.name]={definition:s,value:n},s.aliases&&s.aliases.forEach(a=>{q[a]={definition:s,value:{...n,operator:{...n.operator,name:a}}}}),n}function ce(s,e){const t={type:F.constant,name:s.name,constant:e};q[s.name]={definition:s,value:{type:r.operator,isExecutable:!0,isReadOnly:!0,operator:t}}}const Ce="string",et=4,At=4,Ct=32,le=s=>new TextEncoder().encode(s).length+1,Ne=Symbol("MemoryTracker::MemoryPointer");function ne(s,e){return{bytes:(s.bytes??0)+(e.bytes??0),integers:(s.integers??0)+(e.integers??0),pointers:(s.pointers??0)+(e.pointers??0),values:(s.values??0)+(e.values??0)}}function pe(s){const{bytes:e=0,integers:t=0,pointers:n=0,values:i=0}=s;return e+t*et+n*At+i*Ct}class X{constructor(e={}){d(this,"_total",1/0);d(this,"_used",0);d(this,"_peak",0);d(this,"_byType",{system:0,user:0,string:0});d(this,"_containers",[]);d(this,"_byContainers");d(this,"_strings",new Map);const{total:t=1/0}=e;this._total=t,e.debug&&(this._byContainers=new WeakMap)}isAvailable(e,t){u(!!t);const n=pe(e);return u(n>0),this._used+n<=this._total?{success:!0,value:n}:{success:!1,exception:"vmOverflow"}}allocate(e,t,n){u(t!=="string");const i=this.isAvailable(e,t);if(!i.success)return i;const{value:a}=i;return this.register(a,t,n),{success:!0,value:{[Ne]:!0,bytes:a,type:t}}}release({bytes:e,type:t},n){this.register(-e,t,n)}register(e,t,n){if(e>0){if(this._used+e>this._total)return{success:!1,exception:"vmOverflow"}}else u(e<this._used);if(this._byType[t]+=e,this._used+=e,this._peak=Math.max(this._used,this._peak),this._byContainers&&n!==this){let i=this._byContainers.get(n);if(i===void 0){const a=new WeakRef(n);i={container:a,type:t,total:0,calls:[]},this._containers.push(a),this._byContainers.set(n,i)}if(u(i.type===t,"Unexpected memory type change",{bytes:e,type:t,container:n}),i.total+=e,u(i.total>=0,"Invalid memory registration",{bytes:e,type:t,container:n}),i.total!==0){let a;try{throw new Error}catch(o){a=o.stack}i.calls.push({bytes:e,type:t,stack:a})}else{const a=this._containers.findIndex(o=>o.deref()===n);this._containers.splice(a,1),this._byContainers.delete(n)}}return{success:!0,value:void 0}}*enumContainersAllocations(){if(this._byContainers!==void 0)for(const e of this._containers)yield this._byContainers.get(e.deref())}addStringRef(e){let t=this._strings.get(e)??0;if(t===0){const n=le(e),i=this.register(pe({bytes:n,integers:1}),Ce,this);if(!i.success)return i}return this._strings.set(e,++t),{success:!0,value:t}}releaseString(e){const t=this._strings.get(e);if(u(t!==void 0,"Unable to release string as it is not referenced",e),t===1){const n=le(e);return this.release({[Ne]:!0,bytes:pe({bytes:n,integers:1}),type:Ce},this),this._strings.delete(e),!1}return this._strings.set(e,t-1),!0}get used(){return this._used}get peak(){return this._peak}get total(){return this._total}get byType(){return this._byType}snapshot(){const e={used:this._used,peak:this._peak,total:this._total,byType:this._byType,string:[],system:[],user:[]};for(const[t,n]of this._strings.entries()){const i=le(t);e.string.push({references:n,string:t,size:i,total:i+et})}for(const{container:t,total:n,type:i,calls:a}of this.enumContainersAllocations()){const o={container:{class:"<unknown>"},total:n,calls:a},c=t.deref();c!==void 0&&(o.container.class=c.constructor.name),i===I?e.system.push(o):e.user.push(o)}return e}addValueRef(e){const t=j(e)[0];u(typeof t=="string");const n=this.addStringRef(t);u(n),u(n.value!==1,"addValueRef must not be used to create a new string ref")}releaseValue(e){const t=j(e)[0];return u(typeof t=="string"),this.releaseString(t)}}const Le=s=>{if(s.type===r.array)return s.array;if(s.type===r.dictionary)return s.dictionary;u(!1,"Invalid value type")};class D{constructor(){d(this,"_refCount");this._refCount=1}get refCount(){return this._refCount}addRef(){++this._refCount}release(){const e=--this._refCount;return e===0?(this._dispose(),!1):(u(e>0,"Superfluous release"),!0)}}d(D,"size",{integers:1}),d(D,"tracker",{addValueRef(e){Le(e).addRef()},releaseValue(e){return Le(e).release()}});class ue extends D{constructor(t,n,i,a=1){super();d(this,"_memoryTracker");d(this,"_memoryType");d(this,"_initialCapacity");d(this,"_capacityIncrement");d(this,"_pointers",[]);d(this,"_values",[]);this._memoryTracker=t,this._memoryType=n,this._initialCapacity=i,this._capacityIncrement=a,u(this._initialCapacity>0),u(this._capacityIncrement>=0);const o=this._memoryTracker.allocate(ue.getSize(this._initialCapacity),this._memoryType,this);u(o),this._pointers.push(o.value)}_toValue({isReadOnly:t,isExecutable:n}){return{type:r.array,isReadOnly:t,isExecutable:n,tracker:D.tracker,array:this}}toValue({isReadOnly:t=!0,isExecutable:n=!1}={}){return u(t&&!n,"Unsupported permissions"),this._toValue({isReadOnly:t,isExecutable:n})}static createInstance(t,n,i,a){u(i>0),u(a>=0);const o=t.isAvailable(this.getSize(i),n);if(!o.success)return o;const c=this;return{success:!0,value:new c(t,n,i,a)}}static getSize(t){return ne(D.size,{pointers:1,values:t})}getIncrementSize(t){return{pointers:1,values:t}}get memoryTracker(){return this._memoryTracker}get memoryType(){return this._memoryType}get length(){return this._values.length}at(t){return this._values[t]??y}get capacity(){return this._initialCapacity+(this._pointers.length-1)*this._capacityIncrement}increaseCapacityIfNeeded(t){const n=t-this.capacity;if(n>0){if(this._capacityIncrement===0)return{success:!1,exception:"limitcheck"};let i=Math.ceil(n/this._capacityIncrement);for(;i>0;){const a=this._memoryTracker.allocate(this.getIncrementSize(this._capacityIncrement),this._memoryType,this);if(!a.success)return a;this._pointers.push(a.value),--i}}return{success:!0,value:void 0}}_push(t){var n;for(const i of t)(n=i.tracker)==null||n.addValueRef(i),this.pushImpl(i)}push(...t){const n=this.increaseCapacityIfNeeded(this._values.length+t.length);return n.success?(this._push(t),{success:!0,value:this._values.length}):n}reduceCapacityIfNeeded(t=this._values.length){for(;this._pointers.length>1&&this.capacity-this._capacityIncrement>=t;){const n=this._pointers.at(-1);this._pointers.pop(),this._memoryTracker.release(n,this)}}_pop(){var n;let t=this.popImpl();return t.type!==r.null&&((n=t.tracker)==null?void 0:n.releaseValue(t))===!1&&(t=y),t}pop(){const t=this._pop();return this.reduceCapacityIfNeeded(),t}popush(t,n,...i){const{capacity:a}=this;let o;Array.isArray(n)?o=n.concat(i):n?o=[n].concat(i):o=[];const c=this.length-t+o.length;if(c>a){const p=this.increaseCapacityIfNeeded(c);if(!p.success)return p}for(;t>0;)this._pop(),--t;return this._push(o),this.reduceCapacityIfNeeded(),{success:!0,value:this.length}}clear(){for(;this.length>0;)this._pop();this.reduceCapacityIfNeeded()}_dispose(){this.clear(),this._memoryTracker.release(this._pointers[0],this)}}class Oe extends ue{static create(e,t,n,i){return super.createInstance(e,t,n,i)}get top(){const e=this._values[0];return e===void 0?y:e}pushImpl(e){this._values.unshift(e)}popImpl(){const e=this.at(0);return this._values.shift(),e}}l({name:"aload",description:"loads all items of the array in the operand stack",labels:["array"],signature:{input:[{type:r.array}]},samples:[{in:"[ 1 2 3 ] aload pop",out:"1 2 3"}]},({operands:s},e)=>{const{array:t}=e;return s.popush(1,[...ft(t)],e)});class xe extends ue{static create(e,t,n,i){return super.createInstance(e,t,n,i)}toValue({isReadOnly:e=!0,isExecutable:t=!1}={}){return u(e||!t,"Unsupported permissions"),this._toValue({isReadOnly:e,isExecutable:t})}pushImpl(e){return this._values.push(e),{success:!0,value:void 0}}popImpl(){const e=this._values.at(-1)??y;return this._values.pop(),e}set(e,t){var a,o;if(e<0)return{success:!1,exception:"rangeCheck"};let n=this._values[e]??y;((a=n.tracker)==null?void 0:a.releaseValue(n))===!1&&(n=y);const i=this.increaseCapacityIfNeeded(e+1);return i.success?((o=t.tracker)==null||o.addValueRef(t),this._values[e]=t,{success:!0,value:n}):i}}function we({operands:s,calls:e}){return e.top.debugSource?s.push(Object.assign({debugSource:e.top.debugSource},ke)):s.push(ke)}function tt({operands:s,popCount:e,value:t,mark:n,closeOp:i}){return n.debugSource&&i.debugSource?s.popush(e,Object.assign({debugSource:{...n.debugSource,length:i.debugSource.pos-n.debugSource.pos+i.debugSource.length}},t)):s.popush(e,t)}const Me="markpos",Pe="array",Z=1,de=2;function st(s,{isExecutable:e}){const{operands:t,memoryTracker:n,calls:i}=s,{top:a}=i;if(i.topOperatorState===m){const g=oe(t);if(!g.success)return g;const x=g.value,N=S(x);u(N);const M=i.def(Me,N.value);return M.success&&(i.topOperatorState=Z),M}const o=i.lookup(Me);u(o.type===r.integer);const c=o.integer;if(i.topOperatorState===Z){const g=xe.create(n,Ze,Math.max(c,1),1);if(!g.success)return g;const x=g.value,N=i.def(Pe,x.toValue({isReadOnly:e,isExecutable:e}));return N.success?i.topOperatorState=de:x.release(),N}const p=i.lookup(Pe);u(p.type===r.array);const h=p.array;u(h instanceof xe);const f=i.topOperatorState-de;if(f<c){i.topOperatorState=de+f+1;const g=h.set(c-f-1,t.at(f));return g.success||(h.release(),i.topOperatorState=Z),g}const k=t.at(f),E=tt({operands:t,popCount:1+c,value:p,mark:k,closeOp:a});return E.success?i.topOperatorState=C:i.topOperatorState=Z,h.release(),E}l({name:"]",description:"finalizes an array",labels:["array","mark"],signature:{output:[{type:r.array,permissions:{isReadOnly:!1,isExecutable:!1}}]},samples:[{description:"builds an array and check length and type",in:"[ 1 2 3 ] dup length exch type",out:"3 /array"},{description:"allocates an empty array",in:"[] dup length exch type",out:"0 /array"},{description:"fails if the corresponding array start does not exist",in:" 1 2 3 ]",out:"1 2 3 unmatchedmark"}]},s=>st(s,{isExecutable:!1}));l({name:"[",description:"marks the beginning of an array",labels:["array","mark"],signature:{output:[{type:r.mark}]},samples:[{description:"builds an array and check length and type",in:"[ 1 2 3 ] dup length exch type",out:"3 /array"}]},we);l({name:"and",description:"combines two booleans with and",labels:["boolean"],signature:{input:[{type:r.boolean},{type:r.boolean}],output:[{type:r.boolean}]},samples:[{in:"false false and",out:"false"},{in:"false true and",out:"false"},{in:"true false and",out:"false"},{in:"true true and",out:"true"}]},({operands:s},{isSet:e},{isSet:t})=>s.popush(2,b(e&&t)));l({name:"or",description:"combines two booleans with or",labels:["boolean"],signature:{input:[{type:r.boolean},{type:r.boolean}],output:[{type:r.boolean}]},samples:[{in:"false false or",out:"false"},{in:"false true or",out:"true"},{in:"true false or",out:"true"},{in:"true true or",out:"true"}]},({operands:s},{isSet:e},{isSet:t})=>s.popush(2,b(e||t)));l({name:"xor",description:"combines two booleans with exclusive or",labels:["boolean"],signature:{input:[{type:r.boolean},{type:r.boolean}],output:[{type:r.boolean}]},samples:[{in:"false false xor",out:"false"},{in:"false true xor",out:"true"},{in:"true false xor",out:"true"},{in:"true true xor",out:"false"}]},({operands:s},{isSet:e},{isSet:t})=>s.popush(2,b(e&&!t||!e&&t)));class V extends D{constructor(t,n,i){super();d(this,"_memoryTracker");d(this,"_memoryType");d(this,"_initialCapacity");d(this,"_pointer");d(this,"_slots",{});this._memoryTracker=t,this._memoryType=n,this._initialCapacity=i;const a=this._memoryTracker.allocate(V.getSize(this._initialCapacity),this._memoryType,this);u(a),this._pointer=a.value}toValue({isReadOnly:t=!0,isExecutable:n}={}){return u(n!==!0,"Unsupported permissions"),{type:r.dictionary,isReadOnly:t,isExecutable:!1,tracker:D.tracker,dictionary:this}}static getSize(t){return ne(D.size,{pointers:1+t,values:t})}static create(t,n,i){const a=t.isAvailable(V.getSize(i),n);return a.success?{success:!0,value:new V(t,n,i)}:a}get names(){return Object.keys(this._slots)}lookup(t){var n;return((n=this._slots[t])==null?void 0:n.value)??y}_checkCapacityUsage(){let t=0;for(const n of Object.values(this._slots))n.pointer===this._pointer&&++t;return t}def(t,n){var o,c;let i=this._slots[t],a=(i==null?void 0:i.value)??y;if(i!==void 0){if(((o=a.tracker)==null?void 0:o.releaseValue(a))===!1&&(a=y),n.type===r.null)return i.pointer!==this._pointer&&this._memoryTracker.release(i.pointer,this),this._memoryTracker.releaseString(t),delete this._slots[t],{success:!0,value:a}}else if(n.type!==r.null){const p=this._memoryTracker.addStringRef(t);if(!p.success)return p;if(this._checkCapacityUsage()<this._initialCapacity)i={value:y,pointer:this._pointer};else{const h=this._memoryTracker.allocate({values:1,pointers:3},this._memoryType,this);if(!h.success)return this._memoryTracker.releaseString(t),h;i={value:y,pointer:h.value}}}return u(i!==void 0),i.value=n,(c=n.tracker)==null||c.addValueRef(n),this._slots[t]=i,{success:!0,value:a}}_dispose(){var t;for(const[n,i]of Object.entries(this._slots))this._memoryTracker.releaseString(n),(t=i.value.tracker)==null||t.releaseValue(i.value),i.pointer!==this._pointer&&this._memoryTracker.release(i.pointer,this);this._memoryTracker.release(this._pointer,this)}}l({name:">>",aliases:["»","dicttomark"],description:"finalizes a dictionary",labels:["dictionary","mark"],signature:{output:[{type:r.dictionary,permissions:{isExecutable:!1,isReadOnly:!1}}]},samples:[{description:"builds a dictionary check length and type",in:"<< /test 123 >> dup length exch type",out:"1 /dictionary"},{description:"builds a dictionary check length and type",in:"« /test 123 » dup length exch type",out:"1 /dictionary"},{description:"builds a read/write dictionary",in:"« /test 123 » wcheck",out:"true"},{description:"builds a dictionary check length and type",in:"mark /test 123 dicttomark dup length exch type",out:"1 /dictionary"},{description:"builds a dictionary with shared values, check length and type",in:"<< /test 123 /test_array [ ] /test_dictionary << >> >> dup length exch type",out:"3 /dictionary"},{description:"allocates an empty dictionary",in:"<<>> dup length exch type",out:"0 /dictionary"},{description:"fails if the corresponding dictionary start does not exist",in:"/test 123 >>",out:"/test 123 unmatchedmark"},{description:"fails if the dictionary definition is invalid (names must be strings)",in:"<< 123 /test >>",out:"mark 123 /test typecheck"},{description:"fails if the dictionary definition is invalid (missing name value pair)",in:"<< /test 123 /missing_value >>",out:"mark 123 /test /missing_value typecheck"}]},s=>{const{operands:e,memoryTracker:t,calls:n}=s,i=oe(e);if(!i.success)return i;const a=i.value;if(a%2!==0)return{success:!1,exception:"typeCheck"};for(let f=1;f<a;f+=2)if(e.at(f).type!==r.name)return{success:!1,exception:"typeCheck"};const{top:o}=n,c=V.create(t,Ze,a/2);if(!c.success)return c;const p=c.value;for(let f=0;f<a;f+=2){const k=e.at(f),E=e.at(f+1),[g]=j(E),x=p.def(g,k);if(!x.success)return x}const h=tt({operands:e,popCount:a+1,value:p.toValue({isReadOnly:!1}),mark:e.at(a),closeOp:o});return p.release(),h});l({name:"<<",aliases:["«"],description:"marks the beginning of a dictionary",labels:["dictionary","mark"],signature:{output:[{type:r.mark}]},samples:[{description:"builds a dictionary check length and type",in:"<< /test 123 >> dup length exch type",out:"1 /dictionary"},{description:"builds a dictionary check length and type",in:"« /test 123 » dup length exch type",out:"1 /dictionary"}]},s=>we(s));l({name:"dictstackunderflow",description:"throws the exception : No custom dictionary left to unstack",labels:["exception"],signature:{exceptions:["dictstackunderflow"]},samples:[{in:"dictstackunderflow",out:"dictstackunderflow"}]},()=>({success:!1,exception:"dictStackUnderflow"}));l({name:"invalidaccess",description:"throws the exception : Object is read-only",labels:["exception"],signature:{exceptions:["invalidaccess"]},samples:[{in:"invalidaccess",out:"invalidaccess"}]},()=>({success:!1,exception:"invalidAccess"}));l({name:"limitcheck",description:"throws the exception : An implementation limit has been exceeded",labels:["exception"],signature:{exceptions:["limitcheck"]},samples:[{in:"limitcheck",out:"limitcheck"}]},()=>({success:!1,exception:"limitcheck"}));l({name:"rangecheck",description:"throws the exception : Operand is too big or too small",labels:["exception"],signature:{exceptions:["rangecheck"]},samples:[{in:"rangecheck",out:"rangecheck"}]},()=>({success:!1,exception:"rangeCheck"}));l({name:"stackunderflow",description:"throws the exception : Not enough operands on the stack to perform the operation",labels:["exception"],signature:{exceptions:["stackunderflow"]},samples:[{in:"stackunderflow",out:"stackunderflow"}]},()=>({success:!1,exception:"stackUnderflow"}));l({name:"stop",description:"throws the exception : Execution stopped",labels:["exception"],signature:{exceptions:["stop"]},samples:[{in:"stop",out:"stop"}]},()=>({success:!1,exception:"stop"}));l({name:"typecheck",description:"throws the exception : Operand is of the wrong type",labels:["exception"],signature:{exceptions:["typecheck"]},samples:[{in:"typecheck",out:"typecheck"}]},()=>({success:!1,exception:"typeCheck"}));l({name:"undefined",description:"throws the exception : Name is not defined in the dictionary stack",labels:["exception"],signature:{exceptions:["undefined"]},samples:[{in:"undefined",out:"undefined"}]},()=>({success:!1,exception:"undefined"}));l({name:"undefinedresult",description:"throws the exception : Result cannot be represented as a number",labels:["exception"],signature:{exceptions:["undefinedresult"]},samples:[{in:"undefinedresult",out:"undefinedresult"}]},()=>({success:!1,exception:"undefinedResult"}));l({name:"unmatchedmark",description:"throws the exception : Unmatched mark in the operand stack",labels:["exception"],signature:{exceptions:["unmatchedmark"]},samples:[{in:"unmatchedmark",out:"unmatchedmark"}]},()=>({success:!1,exception:"unmatchedMark"}));l({name:"vmoverflow",description:"throws the exception : Virtual memory exceeded",labels:["exception"],signature:{exceptions:["vmoverflow"]},samples:[{in:"vmoverflow",out:"vmoverflow"}]},()=>({success:!1,exception:"vmOverflow"}));l({name:"}",description:"finalizes a block",labels:["flow","mark"],signature:{output:[{type:r.array,permissions:{isExecutable:!0,isReadOnly:!0}}]},samples:[{description:"builds a block and check length and type",in:"{ 1 2 3 } dup length exch type",out:"3 /array"},{description:"allocated an empty block",in:"{} dup length exch type",out:"0 /array"},{description:"fails if the corresponding block start does not exist",in:"1 2 3 }",out:"1 2 3 unmatchedmark"}]},s=>(s.calls.topOperatorState===m&&s.allowCall(),st(s,{isExecutable:!0})));const Nt="Invalid operator state change";class W extends Oe{constructor(){super(...arguments);d(this,"_dictionaries",[]);d(this,"_steps",[])}static create(t,n,i,a){return u(n===I),super.createInstance(t,n,i,a)}static getSize(t){return ne(super.getSize(t),{integers:t,pointers:t})}getIncrementSize(t){return ne(super.getIncrementSize(t),{integers:t,pointers:t})}pushImpl(t){super.pushImpl(t),this._dictionaries.unshift(void 0),this._steps.unshift(A)}popImpl(){const t=super.popImpl(),n=this._dictionaries[0];return n!==void 0&&n.release(),this._dictionaries.shift(),this._steps.shift(),t}snapshot(){const t=W.create(this.memoryTracker,this.memoryType,this.length,0);if(!t.success)return t;const n=t.value;let i=this.length;for(;--i>=0;)n.push(this.at(i)),n._steps[0]=this.operatorStateAt(i);return{success:!0,value:n}}operatorStateAt(t){return this._steps[t]??A}get names(){return[]}lookup(t){const n=this._dictionaries[0];return n===void 0?y:n.lookup(t)}def(t,n){if(this.length===0)return{success:!1,exception:"stackUnderflow"};let i=this._dictionaries[0];if(i===void 0){const a=V.create(this.memoryTracker,I,1);if(!a.success)return a;i=a.value,this._dictionaries[0]=i}return i.def(t,n)}get topOperatorState(){return u(this.length>0),this._steps[0]}set topOperatorState(t){const n=this.topOperatorState;(n===A&&t!==m||n!==A&&t===m||t===A||n===C||t!==C&&(n>m&&t<R||n<R&&t>=R||n===R&&t>m||n===m&&t<R))&&u(!1,Nt),this._steps[0]=t}}const De="block",Ve="exception",He="stack",$e=-2;l({name:"finally",description:"executes the final block whenever the command block is unstacked",labels:["flow"],signature:{input:[{type:r.array,permissions:{isExecutable:!0}},{type:r.array,permissions:{isExecutable:!0}}]},samples:[{description:"always executes the final block",in:"{ 1 2 } { 3 } finally",out:"1 2 3"},{description:"does not prevent exception but enables post processing",in:"{ 1 undefined 2 } { 3 } finally",out:"1 3 undefined"},{description:"throws the last error",in:"{ 1 stackunderflow 2 } { 3 undefined 4 } finally",out:"1 3 undefined"},{description:"fails on no code block",in:"[ 1 2 ] { 3 } finally",out:"[ 1 2 ] { 3 } typecheck"}]},(s,e,t)=>{const{operands:n,calls:i}=s,{topOperatorState:a}=i;if(a===m){const o=i.def(De,t);if(!o.success)return o;i.topOperatorState=R;const c=i.push(e);if(c.success){const p=n.popush(2);u(p)}return c}if(a===R){if(i.topOperatorState=$e,s.exception){const c=i.def(Ve,G(s.exception));if(!c.success)return c;u(s.exceptionStack instanceof W);const p=i.def(He,s.exceptionStack.toValue());if(!p.success)return p;s.clearException()}const o=i.lookup(De);return u(o.type!==r.null),i.push(o)}if(u(a===$e),s.exception===void 0){const o=i.lookup(Ve);if(o!==y){u(o.type===r.string);const c=i.lookup(He);u(c.type===r.array),s.raiseException(o.string,c.array)}}return i.topOperatorState=C,{success:!0,value:void 0}});l({name:"if",description:"executes the operand based on a condition",labels:["flow"],signature:{input:[{type:r.boolean},{type:r.null}]},samples:[{in:"mark true { 123 } if",out:"mark 123"},{in:"mark false { 123 } if",out:"mark"},{description:"supports operand that is not a block",in:"mark true 123 if",out:"mark 123"}]},({operands:s,calls:e},{isSet:t},n)=>(s.popush(2),t?e.push(n):{success:!0,value:void 0}));l({name:"ifelse",description:"executes the operands based on a condition",labels:["flow"],signature:{input:[{type:r.boolean},{type:r.null},{type:r.null}]},samples:[{in:"mark true { 123 } { 456 } ifelse",out:"mark 123"},{in:"mark false { 123 } { 456 } ifelse",out:"mark 456"},{description:"supports operands that are not blocks",in:"mark true 123 456 ifelse",out:"mark 123"}]},({operands:s,calls:e},{isSet:t},n,i)=>(s.popush(3),t?e.push(n):e.push(i)));const Be="block";l({name:"loop",description:"repeatedly executes proc until proc executes the stop operator",labels:["flow","loop"],signature:{input:[{type:r.array,permissions:{isExecutable:!0}}]},samples:[{description:"executes the block until stop",in:"{ 1 count 3 eq { stop } if } loop",out:"1 1 1"},{description:"does not catch errors",in:"{ 1 typecheck } loop",out:"1 typecheck"},{description:"fails on no code block",in:"[ 1 2 ] loop",out:"[ 1 2 ] typecheck"}]},(s,e)=>{const{operands:t,calls:n}=s,{topOperatorState:i}=n;if(i===m)return n.topOperatorState=R,n.def(Be,e),t.pop(),n.push(e);if(u(i===R),s.exception)return s.exception==="stop"&&s.clearException(),n.topOperatorState=C,{success:!0,value:void 0};const a=n.lookup(Be);return n.push(a)});l({name:"{",description:"marks the beginning of a block",labels:["flow","mark"],samples:[{description:"builds a block and check length and type",in:"{ 1 2 3 } dup length exch type",out:"3 /array"}]},s=>{const e=we(s);return e.success&&s.preventCall(),e});l({name:"stopped",description:"executes the value. If execution was interrupted with stop, return true, return false otherwise",labels:["flow"],signature:{input:[{type:r.null}]},samples:[{in:"{ 1 2 3 } stopped",out:"1 2 3 false"},{in:"{ 1 2 stop 3 } stopped",out:"1 2 true"},{in:"{ 1 2 typecheck 3 } stopped",out:"1 2 typecheck"}]},(s,e)=>{const{operands:t,calls:n}=s,{topOperatorState:i}=n;if(i===m){n.topOperatorState=R;const a=n.push(e);return a.success&&t.pop(),a}return u(i===R),n.topOperatorState=C,s.exception?s.exception==="stop"?(s.clearException(),t.push(b(!0))):{success:!0,value:void 0}:t.push(b(!1))});l({name:"abs",description:"returns absolute values of an integer",labels:["integer","math"],signature:{input:[{type:r.integer}],output:[{type:r.integer}]},samples:[{in:"1 abs",out:"1"},{in:"-1 abs",out:"1"}]},(s,{integer:e})=>{const{operands:t}=s;if(e<0){const n=S(-e);return n.success?t.popush(1,n.value):n}return{success:!0,value:void 0}});l({name:"add",description:"adds two integers",labels:["integer","math"],signature:{input:[{type:r.integer},{type:r.integer}],output:[{type:r.integer}]},samples:[{in:"1 2 add",out:"3"}]},(s,{integer:e},{integer:t})=>{const{operands:n}=s,i=S(e+t);return i.success?n.popush(2,i.value):i});l({name:"div",description:"realizes an euclidean division with two integers",labels:["integer","math"],signature:{input:[{type:r.integer},{type:r.integer}],output:[{type:r.integer},{type:r.integer}]},samples:[{in:"5 3 div",out:"1 2"},{in:"5 0 div",out:"undefinedresult"}]},(s,{integer:e},{integer:t})=>{const{operands:n}=s;if(t===0)return{success:!1,exception:"undefinedResult"};const i=e%t,a=S(i);if(!a.success)return a;const o=S((e-i)/t);return o.success?n.popush(2,o.value,a.value):o});l({name:"gt",description:"compares two integers to see if greater than",labels:["integer","math","comparison"],signature:{input:[{type:r.integer},{type:r.integer}],output:[{type:r.boolean}]},samples:[{in:"1 2 gt",out:"false"},{in:"2 1 gt",out:"true"}]},({operands:s},{integer:e},{integer:t})=>s.popush(2,b(e>t)));l({name:"gte",description:"compares two integers to see if greater than or equal",labels:["integer","math","comparison"],signature:{input:[{type:r.integer},{type:r.integer}],output:[{type:r.boolean}]},samples:[{in:"1 2 gte",out:"false"},{in:"2 1 gte",out:"true"},{in:"1 1 gte",out:"true"}]},({operands:s},{integer:e},{integer:t})=>s.popush(2,b(e>=t)));l({name:"lt",description:"compares two integers to see if lower than",labels:["integer","math","comparison"],signature:{input:[{type:r.integer},{type:r.integer}],output:[{type:r.boolean}]},samples:[{in:"1 2 lt",out:"true"},{in:"2 1 lt",out:"false"}]},({operands:s},{integer:e},{integer:t})=>s.popush(2,b(e<t)));l({name:"lte",description:"compares two integers to see if lower than or equal",labels:["integer","math","comparison"],signature:{input:[{type:r.integer},{type:r.integer}],output:[{type:r.boolean}]},samples:[{in:"1 2 lte",out:"true"},{in:"2 1 lte",out:"false"},{in:"1 1 lte",out:"true"}]},({operands:s},{integer:e},{integer:t})=>s.popush(2,b(e<=t)));l({name:"mul",description:"multiplies two integers",labels:["integer","math"],signature:{input:[{type:r.integer},{type:r.integer}],output:[{type:r.boolean}]},samples:[{in:"3 4 mul",out:"12"}]},(s,{integer:e},{integer:t})=>{const{operands:n}=s,i=S(e*t);return i.success?n.popush(2,i.value):i});l({name:"sub",description:"subtracts two integers",labels:["integer","math"],signature:{input:[{type:r.integer},{type:r.integer}],output:[{type:r.boolean}]},samples:[{in:"1 2 sub",out:"-1"}]},(s,{integer:e},{integer:t})=>{const{operands:n}=s,i=S(e-t);return i.success?n.popush(2,i.value):i});l({name:"countexecstack",description:"retrieves the number of dictionaries in the dictionary stack",labels:["callstack"],signature:{output:[{type:r.integer}]},samples:[{in:"countexecstack",out:"3"}]},({operands:s,calls:e})=>{const t=S(e.length);return u(t),s.push(t.value)});l({name:"begin",description:"pushes the dictionary on the dictionary stack, making it the current one",labels:["dictstack"],signature:{input:[{type:r.dictionary}]},samples:[{in:"<< /test 1 >> begin test end",out:"1"}]},({operands:s,dictionaries:e},t)=>{const n=e.push(t);return n.success&&s.pop(),n});const Lt=l({name:"pop",description:"removes the top item of the operand stack",labels:["operand"],signature:{input:[{type:r.null}]},samples:[{in:"1 2 3 pop",out:"1 2"}]},({operands:s})=>s.pop()),Mt=l({name:"bind",description:"binds the block calls to their value by resolving the names from the dictionary stack",labels:["dictstack","flow"],signature:{input:[{type:r.array,permissions:{isExecutable:!0}}],output:[{type:r.array,permissions:{isExecutable:!0}}]},samples:[{in:"{ clear } bind 0 get",out:"systemdict /clear get"},{description:"does not fail on unknown names",in:"{ clear test_unknown bind } bind 2 get",out:"systemdict /bind get"},{description:"works recursively",in:"{ clear { bind } } bind 1 get 0 get",out:"systemdict /bind get"},{description:"works only on code blocks",in:"[ 1 2 ] bind",out:"[ 1 2 ] typecheck"},{description:"does nothing when no names are used",in:"{ {} 1 2 3 } bind",out:"{ {} 1 2 3 }"},{description:"works on mixed content",in:"{ 1 clear } bind 1 get",out:"systemdict /clear get"}]},s=>{const{operands:e,calls:t,dictionaries:n}=s,{topOperatorState:i}=t,a=e.top;u(vt(a));const{array:o}=a;if(u(o instanceof xe),i<o.length){const c=o.at(i);if(c&&c.isExecutable){if(c.type===r.name){const p=n.where(c.name);if(p!==null){const h=o.set(i,p.value);if(!h.success)return h}t.topOperatorState=i+1}else if(c.type===r.array){t.topOperatorState=i+1;const p=e.push(c);if(!p.success)return p;const h=t.push(Lt);if(!h.success)return h;const f=t.push(Mt);if(!f.success)return f}}else t.topOperatorState=i+1}else t.topOperatorState=C;return{success:!0,value:void 0}});l({name:"countdictstack",description:"retrieves the number of dictionaries in the dictionary stack",labels:["dictstack"],signature:{output:[{type:r.integer}]},samples:[{in:"countdictstack",out:"4"}]},({operands:s,dictionaries:e})=>{const t=S(e.length);return u(t.success),s.push(t.value)});l({name:"currentdict",description:"retrieves the top of the dictionary stack",labels:["dictstack"],signature:{output:[{type:r.dictionary}]},samples:[{in:"currentdict type",out:"/dictionary"}]},({operands:s,dictionaries:e})=>s.push(e.top));l({name:"def",description:"associates key with value in the current dictionary, the one on the top of the dictionary stack",labels:["dictstack"],signature:{input:[{type:r.name},{type:r.null}]},samples:[{in:"/test 1 def test",out:"/test 1 def 1"},{in:"systemdict begin /test 1 def test",out:"systemdict begin /test 1 invalidaccess"}]},({operands:s,dictionaries:e},{name:t},n)=>{if(e.top.isReadOnly)return{success:!1,exception:"invalidAccess"};const{dictionary:i}=e.top,a=i.def(t,n);return a.success?s.popush(2):a});l({name:"end",description:"pops the current dictionary off the dictionary stack, making the dictionary below it the current dictionary",labels:["dictstack"],samples:[{in:"<< /test 1 >> begin end test",out:"undefined"}]},({dictionaries:s})=>s.pop());l({name:"globaldict",description:"retrieves the global dictionary from the dictionary stack",labels:["dictstack"],signature:{output:[{type:r.dictionary}]},samples:[{in:"globaldict type",out:"/dictionary"}]},({operands:s,dictionaries:e})=>s.push(e.global));l({name:"systemdict",description:"retrieves the system dictionary from the dictionary stack",labels:["dictstack"],signature:{output:[{type:r.dictionary}]},samples:[{in:"systemdict type",out:"/dictionary"}]},({operands:s,dictionaries:e})=>s.push(e.system));l({name:"userdict",description:"retrieves the user dictionary from the dictionary stack",labels:["dictstack"],signature:{output:[{type:r.dictionary}]},samples:[{in:"userdict type",out:"/dictionary"}]},({operands:s,dictionaries:e})=>s.push(e.user));l({name:"clear",description:"clears the operand stack",labels:["operand"],samples:[{in:"1 2 3 clear",out:""}]},({operands:s})=>{for(;s.length;)s.pop()});l({name:"cleartomark",description:"clears the operand stack up to the first mark",labels:["operand","mark"],samples:[{in:"1 mark 2 3 cleartomark",out:"1"},{description:"fails if no mark is found",in:"1 2 3 cleartomark",out:"1 2 3 unmatchedmark"}]},({operands:s})=>{const e=oe(s);return e.success?s.popush(e.value+1):e});l({name:"count",description:"gives back the size of the operand stack",labels:["operand"],signature:{output:[{type:r.integer}]},samples:[{in:"1 2 3 count",out:"1 2 3 3"}]},({operands:s})=>{const e=S(s.length);return u(e.success),s.push(e.value)});l({name:"counttomark",description:"count the number of items in the operand stack up to the first mark",labels:["operand"],signature:{output:[{type:r.integer}]},samples:[{in:"1 mark 2 3 counttomark",out:"1 mark 2 3 2"},{description:"fails if no mark is found",in:"1 2 3 counttomark",out:"1 2 3 unmatchedmark"}]},({operands:s})=>{const e=oe(s);if(!e.success)return e;const t=S(e.value);return u(t.success),s.push(t.value)});l({name:"dup",description:"duplicates the top item of the operand stack",labels:["operand"],signature:{input:[{type:r.null}],output:[{type:r.null},{type:r.null}]},samples:[{in:"1 2 3 dup",out:"1 2 3 3"}]},({operands:s},e)=>s.push(e));l({name:"exch",description:"swaps the first two items of the operand stack",labels:["operand"],signature:{input:[{type:r.null},{type:r.null}],output:[{type:r.null},{type:r.null}]},samples:[{in:"1 2 3 exch",out:"1 3 2"}]},({operands:s},e,t)=>s.popush(2,t,e));l({name:"index",description:"duplicates the Nth item of the operand stack",labels:["operand"],signature:{input:[{type:r.integer}],output:[{type:r.null}]},samples:[{in:"1 2 3 1 index",out:"1 2 3 2"},{description:"throws stackunderflow if index is too big",in:"1 2 3 5 index",out:"1 2 3 5 stackunderflow"}]},({operands:s},{integer:e})=>e>s.length?{success:!1,exception:"stackUnderflow"}:s.popush(1,s.at(e+1)));l({name:"roll",description:"performs a circular shift of the values on the operand stack by a given amount",labels:["operand"],signature:{input:[{type:r.integer},{type:r.integer}]},samples:[{in:"100 200 300 3 -1 roll",out:"200 300 100"},{in:"100 200 300 3 1 roll",out:"300 100 200"},{in:"100 200 300 3 0 roll",out:"100 200 300"},{in:'"a" "b" "c" 3 2 roll',out:'"b" "c" "a"'},{description:"fails if the number of values to roll is invalid",in:"100 200 300 0 0 roll",out:"100 200 300 0 0 rangecheck"},{description:"fails if the number of values to roll is invalid",in:"100 200 300 -1 0 roll",out:"100 200 300 0 0 rangecheck"},{description:"fails if the number of values to roll is invalid",in:"100 200 300 4 0 roll",out:"100 200 300 0 0 rangecheck"},{description:"fails if the number of values to roll is invalid",in:"100 200 300 50 0 roll",out:"100 200 300 0 0 rangecheck"}]},({operands:s},{integer:e},{integer:t})=>{var i,a;if(e<=0||e>s.length-2)return{success:!1,exception:"rangeCheck"};if(s.pop(),s.pop(),t=-t%e,t===0)return;t<0&&(t+=e);const n=[];try{for(let o=e;o>0;--o){const c=s.top;n.unshift(c),(i=c.tracker)==null||i.addValueRef(c),s.pop()}for(let o=0;o<e;++o){const c=n[(o+t)%e];s.push(c)}}finally{for(const o of n)(a=o.tracker)==null||a.releaseValue(o)}return{success:!0,value:void 0}});l({name:"cvi",description:"converts to integer",labels:["value","generic","conversion"],signature:{input:[{type:r.null}],output:[{type:r.integer}]},samples:[{in:"1 cvi",out:"1"},{in:'"1" cvi',out:"1"},{description:"fails if number goes beyond limit",in:'"9007199254740992" cvi',out:"undefinedresult"},{in:"/1 cvi",out:"typecheck"},{in:"<< >> cvi",out:"typecheck"}]},({operands:s},e)=>{if(e.type!==r.integer)if(e.type===r.string){const t=parseInt(e.string,10),n=S(t);return n.success?s.popush(1,n.value):n}else return{success:!1,exception:"typeCheck"};return{success:!0,value:void 0}});l({name:"cvlit",description:"removes executable flag",labels:["value","generic","conversion"],signature:{input:[{type:r.null}],output:[{type:r.null,permissions:{isExecutable:!1}}]},samples:[{in:"1 cvlit",out:"1"},{description:"converts a block to a read-only array",in:"{ 1 } cvlit dup xcheck exch wcheck",out:"false false"},{description:"converts a call to a name",in:"{ test } 0 get cvlit",out:"/test"}]},({operands:s},e)=>e.isExecutable?s.popush(1,{...e,isExecutable:!1}):{success:!0,value:void 0});l({name:"cvn",description:"converts to name",labels:["value","generic","conversion"],signature:{input:[{type:r.string}],output:[{type:r.name}]},samples:[{in:'"test" cvn',out:"/test"},{in:"/test cvn",out:"typecheck"},{in:"1 cvn",out:"typecheck"}]},({operands:s,memoryTracker:e},{string:t})=>{u(e instanceof X);const n=e.addStringRef(t);if(!n.success)return n;const i=s.popush(1,Qe(t,{tracker:e}));return e.releaseString(t),i});l({name:"eq",description:"compares two values and return true if they are strictly equal",labels:["generic","comparison"],signature:{input:[{type:r.null},{type:r.null}],output:[{type:r.boolean}]},samples:[{in:"1 1 eq",out:"true"},{in:"1 2 eq",out:"false"},{in:'1 "1" eq',out:"false"},{in:"[ ] [ ] eq",out:"false"},{in:"[ ] dup eq",out:"true"}]},({operands:s},e,t)=>{let n;if(e.type!==t.type)n=!1;else{const[i,a]=j(e,t);n=i===a}return s.popush(2,b(n))});ce({name:"false",description:"pushes false in the operand stack",labels:["value"],signature:{output:[{type:r.boolean}]},samples:[{in:"false type",out:"/boolean"}]},b(!1));const Pt={[r.string]:({string:s,tracker:e},t)=>{u(e instanceof X);const n=se(t,s.length);if(!n.success)return n;const i=s.charAt(n.value),a=e.addStringRef(i);return a.success?{success:!0,value:G(i,{tracker:e})}:a},[r.array]:({array:s},e)=>{var i;const t=se(e,s.length);if(!t.success)return t;const n=s.at(t.value);return(i=n.tracker)==null||i.addValueRef(n),{success:!0,value:n}},[r.dictionary]:({dictionary:s},e)=>{var i;if(e.type!==r.name)return{success:!1,exception:"typeCheck"};const{name:t}=e;if(!s.names.includes(t))return{success:!1,exception:"undefined"};const n=s.lookup(t);return(i=n.tracker)==null||i.addValueRef(n),{success:!0,value:n}}};l({name:"get",description:"returns an indexed item from the value",labels:["generic"],signature:{input:[{type:r.null},{type:r.null}],output:[{type:r.null}]},samples:[{description:"returns the Nth item of an array",in:"[ 1 2 3 ] 1 get",out:"2"},{description:"returns the Nth item of an executable array",in:"{ 1 2 3 } 1 get",out:"2"},{description:"fails if invalid index for the array",in:"[ 1 2 3 ] /a get",out:"[ 1 2 3 ] /a typecheck"},{description:"fails if out of bound index for the array",in:"[ 1 2 3 ] -1 get",out:"[ 1 2 3 ] -1 rangecheck"},{description:"fails if out of bound index for the array",in:"[ 1 2 3 ] 3 get",out:"[ 1 2 3 ] -1 rangecheck"},{description:"returns the Nth character of a string",in:'"abc" 1 get',out:'"b"'},{description:"fails if invalid index for a string",in:'"abc" "a" get',out:'"abc" "a" typecheck'},{description:"fails if out of bound index for a string",in:'"abc" -1 get',out:'"abc" -1 rangecheck'},{description:"fails if out of bound index for a string",in:'"abc" 3 get',out:'"abc" 3 rangecheck'},{description:"returns the indexed item of a dictionary",in:"systemdict /get get",out:"{ get } bind 0 get"},{description:"returns the indexed item of a dictionary (handles reference counting)",in:'/test "abc" def userdict /test get',out:'/test "abc" def "abc"'},{description:"fails if invalid index for a dictionary",in:"systemdict 0 get",out:"systemdict 0 typecheck"},{description:"fails if unknown index for a dictionary",in:"systemdict /not_an_operator get",out:"systemdict /not_an_operator undefined"},{description:"fails if not a container",in:"1 1 get",out:"1 1 typecheck"},{description:"fails if not a container",in:"false 1 get",out:"false 1 typecheck"},{description:"fails if not a container",in:"mark 1 get",out:"mark 1 typecheck"}]},({operands:s},e,t)=>{var c;const n=Pt[e.type];if(n===void 0)return{success:!1,exception:"typeCheck"};const i=n(e,t);if(!i.success)return i;const{value:a}=i,o=s.popush(2,a);return(c=a.tracker)==null||c.releaseValue(a),o});const Dt={[r.string]:({string:s})=>s.length,[r.array]:({array:s})=>s.length,[r.dictionary]:({dictionary:s})=>s.names.length};l({name:"length",description:"returns the length of the value",labels:["generic"],signature:{input:[{type:r.null}],output:[{type:r.integer}]},samples:[{description:"returns the number of items in an array",in:"[ 1 2 3 ] length",out:"3"},{description:"returns the number of items in an executable array",in:"{ 1 2 3 } length",out:"3"},{description:"returns the size of a string",in:'"abc" length',out:"3"},{description:"returns the number of keys in a dictionary",in:"systemdict length 0 gt",out:"true"},{description:"fails if not a container",in:"1 length",out:"1 typecheck"},{description:"fails if not a container",in:"false length",out:"false typecheck"},{description:"fails if not a container",in:"mark length",out:"mark typecheck"}]},({operands:s},e)=>{const t=Dt[e.type];if(t===void 0)return{success:!1,exception:"typeCheck"};const n=S(t(e));return u(n.success),s.popush(1,n.value)});ce({name:"mark",description:"pushes a mark in the operand stack",labels:["value","mark"],signature:{output:[{type:r.mark}]},samples:[{in:"1 2 mark",out:"1 2 mark"},{description:"marks part of the stack for operations",in:"1 2 mark 3 4 5 cleartomark",out:"1 2"}]},ke);l({name:"neq",description:"compares two values and return true if they are strictly different",labels:["generic","comparison"],signature:{input:[{type:r.null},{type:r.null}],output:[{type:r.boolean}]},samples:[{in:"1 1 neq",out:"false"},{in:"1 2 neq",out:"true"},{in:'1 "1" neq',out:"true"},{in:"[ ] [ ] neq",out:"true"},{in:"[ ] dup neq",out:"false"}]},({operands:s},e,t)=>{let n;if(e.type!==t.type)n=!0;else{const[i,a]=j(e,t);n=i!==a}return s.popush(2,b(n))});const Vt={[r.string]:({string:s,tracker:e},t,n)=>{if(u(e instanceof X),n.type!==r.integer)return{success:!1,exception:"typeCheck"};const{integer:i}=n;if(i<0||i>65535)return{success:!1,exception:"rangeCheck"};const a=se(t,s.length);if(!a.success)return a;const o=s.substring(0,a.value)+String.fromCharCode(i)+s.substring(a.value+1),c=e.addStringRef(o);return c.success?{success:!0,value:G(o,{tracker:e})}:c},[r.array]:(s,e,t)=>{var c;const{array:n,isReadOnly:i}=s;if(i)return{success:!1,exception:"invalidAccess"};const a=se(e,n.length);if(!a.success)return a;const o=n.set(a.value,t);return o.success?((c=s.tracker)==null||c.addValueRef(s),{success:!0,value:s}):o},[r.dictionary]:(s,e,t)=>{var c;const{dictionary:n,isReadOnly:i}=s;if(i)return{success:!1,exception:"invalidAccess"};if(e.type!==r.name)return{success:!1,exception:"typeCheck"};const{name:a}=e,o=n.def(a,t);return o.success?((c=s.tracker)==null||c.addValueRef(s),{success:!0,value:s}):o}};l({name:"put",description:"sets an indexed item in the value",postScriptDeviation:"returns the modified object or a new string",labels:["generic"],signature:{input:[{type:r.null},{type:r.null},{type:r.null}],output:[{type:r.null}]},samples:[{description:"sets the Nth item of an array",in:"[ 1 2 3 ] 1 5 put",out:"[ 1 5 3 ]"},{description:"fails if the array is not writable",in:"{ 1 2 3 } 1 5 put",out:"{ 1 2 3 } 1 5 invalidaccess"},{description:"fails if invalid index for the array",in:'[ 1 2 3 ] "a" 5 put',out:'[ 1 2 3 ] "a" 5 typecheck'},{description:"fails if out of bound index for the array",in:"[ 1 2 3 ] -1 5 put",out:"[ 1 2 3 ] -1 5 rangecheck"},{description:"fails if out of bound index for the array",in:"[ 1 2 3 ] 3 5 put",out:"[ 1 2 3 ] 3 5 rangecheck"},{description:"sets the Nth character of a string (returns a new string, using ascii code)",in:'"abc" 1 66 put',out:'"aBc"'},{description:"fails if setting an invalid value",in:'"abc" 1 "B" put',out:'"abc" 1 "B" typecheck'},{description:"fails if setting an invalid value",in:'"abc" 1 -1 put',out:'"abc" 1 -1 rangecheck'},{description:"fails if setting an invalid value",in:'"abc" 1 65536 put',out:'"abc" 1 65536 rangecheck'},{description:"fails if invalid index for a string",in:'"abc" "a" 66 put',out:'"abc" "a" 66 typecheck'},{description:"fails if out of bound index for a string",in:'"abc" -1 66 put',out:'"abc" -1 66 rangecheck'},{description:"fails if out of bound index for a string",in:'"abc" 3 66 put',out:'"abc" 3 66 rangecheck'},{description:"sets an indexed item of a dictionary",in:"userdict /test 123 put pop test",out:"userdict /test 456 put pop 123"},{description:"fails if the dictionary is not writable",in:"systemdict /test 123 put",out:"systemdict /test 123 invalidaccess"},{description:"fails if invalid index for a dictionary",in:"userdict 0 123 put",out:"userdict 0 123 typecheck"},{description:"fails if not a container",in:"1 0 1 put",out:"1 0 1 typecheck"},{description:"fails if not a container",in:"false 0 1 put",out:"false 0 1 typecheck"},{description:"fails if not a container",in:"mark 0 1 put",out:"mark 0 1 typecheck"}]},({operands:s},e,t,n)=>{var p;const i=Vt[e.type];if(i===void 0)return{success:!1,exception:"typeCheck"};const a=i(e,t,n);if(!a.success)return a;const{value:o}=a,c=s.popush(3,o);return(p=e.tracker)==null||p.releaseValue(o),c});ce({name:"true",description:"pushes true in the operand stack",labels:["value"],signature:{output:[{type:r.boolean}]},samples:[{in:"true type",out:"/boolean"}]},b(!0));l({name:"type",description:"pushes the type of the value in the operand stack",labels:["value","generic"],signature:{input:[{type:r.null}],output:[{type:r.name}]},samples:[{in:"false type",out:"/boolean"},{in:"[ 1 2 3 ] type",out:"/array"},{in:'"" type',out:"/string"},{in:"/type type",out:"/name"}]},({operands:s,memoryTracker:e},t)=>{u(e instanceof X);const{type:n}=t,i=e.addStringRef(n);if(!i.success)return i;const a=s.popush(1,Qe(n,{tracker:e}));return e.releaseString(n),a});const Ht="@psbots/engine@0.0.1";ce({name:"version",description:"returns a string that identifies the version of the engine",labels:["value"],signature:{output:[{type:r.string}]},samples:[{in:"version type",out:"/string"}]},G(Ht));l({name:"wcheck",description:"checks if value is writable",labels:["value","generic","permission"],signature:{input:[{type:r.null}],output:[{type:r.boolean}]},samples:[{description:"returns false for blocks",in:"{ 1 2 } wcheck",out:"false"},{description:"returns true for arrays",in:"[ 1 2 ] wcheck",out:"true"}]},({operands:s},e)=>s.popush(1,b(!e.isReadOnly)));l({name:"xcheck",description:"checks if value is executable",labels:["value","generic","permission"],signature:{input:[{type:r.null}],output:[{type:r.boolean}]},samples:[{description:"returns true for blocks",in:"{ 1 2 } xcheck",out:"true"},{description:"returns false for arrays",in:"[ 1 2 ] xcheck",out:"false"}]},({operands:s},e)=>s.popush(1,b(e.isExecutable)));const re=class re{constructor(){}static get instance(){return this._instance??(this._instance=new re),this._instance}get names(){return Object.keys(q)}lookup(e){const t=q[e];return t!==void 0?t.value:y}};d(re,"_instance");let ve=re;const ae=class ae{constructor(){}static get instance(){return this._instance??(this._instance=new ae),this._instance}get names(){return[]}lookup(){return y}def(e,t){return u(!!e),u(!!t),{success:!1,exception:"invalidAccess"}}};d(ae,"_instance");let B=ae;const Q=4,ze=-1,$t=-2,he=-3,fe=-4;class Bt extends Oe{static create(e,t,n,i){return u(t===I),u(n>4),super.createInstance(e,t,n,i)}constructor(e,t,n,i){super(e,t,n,i),this.begin({type:r.dictionary,isExecutable:!1,isReadOnly:!0,dictionary:B.instance}),this.begin({type:r.dictionary,isExecutable:!1,isReadOnly:!0,dictionary:ve.instance}),this.begin({type:r.dictionary,isExecutable:!1,isReadOnly:!1,dictionary:B.instance}),this.begin({type:r.dictionary,isExecutable:!1,isReadOnly:!1,dictionary:B.instance})}getDictionaryValue(e){const t=this._values[this._values.length+e];return u(!!t&&t.type===r.dictionary),t}setHost(e){var t;this._values[Q+ze]=e,(t=e.tracker)==null||t.addValueRef(e)}setGlobal(e){var n;const t=this.getDictionaryValue(he);u(t.dictionary===B.instance),this._values[Q+he]=e,(n=e.tracker)==null||n.addValueRef(e)}setUser(e){var n;const t=this.getDictionaryValue(fe);u(t.dictionary===B.instance),this._values[Q+fe]=e,(n=e.tracker)==null||n.addValueRef(e)}get top(){return super.top}get host(){return this.getDictionaryValue(ze)}get system(){return this.getDictionaryValue($t)}get global(){return this.getDictionaryValue(he)}get user(){return this.getDictionaryValue(fe)}begin(e){return this.push(e)}end(){return this.length===Q?{success:!1,exception:"dictStackUnderflow"}:(this.pop(),{success:!0,value:this.length})}where(e){for(const t of this._values){const{dictionary:n}=t,i=n.lookup(e);if(i.type!==r.null)return{dictionary:n,value:i}}return null}lookup(e){const t=this.where(e);return t===null?{success:!1,exception:"undefined"}:{success:!0,value:t.value}}}function nt(s,e){const{calls:t}=s,n=e.operator;if(t.topOperatorState>=m||t.topOperatorState===C)t.pop();else{const i=n.implementation(s);i&&i.success===!1&&s.raiseException(i.exception)}}function zt(s,e){var p,h;const{operands:t,calls:n,memoryTracker:i}=s;if(u(i instanceof X),n.topOperatorState<=m){nt(s,e);return}const{top:a}=n,o=n.topOperatorState===A;o&&(n.topOperatorState=m);const c=e.operator;if(c.type===F.constant)t.push(c.constant),n.pop();else{let f;const k=[];if(c.typeCheck!==void 0&&o){let{length:x}=c.typeCheck;if(t.length<x){s.raiseException("stackUnderflow");return}const N=i.allocate({values:x},I,s);if(!N.success){s.raiseException(N.exception);return}f=N.value;for(const{type:M,permissions:pt}of c.typeCheck){const J=t.at(--x),{isReadOnly:Ee,isExecutable:Te}=pt??{};if((M===r.null||M===J.type)&&(Ee===void 0||Ee===J.isReadOnly)&&(Te===void 0||Te===J.isExecutable))k.push(J);else{s.raiseException("typeCheck"),i.release(f,s);return}}for(const M of k)(p=M.tracker)==null||p.addValueRef(M)}const E=s.exception,g=c.implementation(s,...k);if(f!==void 0){for(const x of k)(h=x.tracker)==null||h.releaseValue(x);i.release(f,s)}if(g&&g.success===!1&&s.raiseException(g.exception),s.exception!==E)return;n.length&&n.top===a&&(n.topOperatorState===C||n.topOperatorState===m)&&n.pop()}}function Ut(s,e){const{dictionaries:t,calls:n,callEnabled:i,operands:a}=s;if(n.topOperatorState===m)n.pop();else if(i||["{","}","<<","«",">>","»"].includes(e.name)){n.topOperatorState=m;const o=t.lookup(e.name);if(!o.success){s.raiseException(o.exception);return}const c=o.value;e.debugSource?n.push(Object.assign({debugSource:e.debugSource},c)):n.push(c)}else a.push(e),n.pop()}function Ft({calls:s,operands:e},{array:t}){const{length:n}=t;if(s.topOperatorState===A?s.topOperatorState=m:s.topOperatorState++,s.topOperatorState===n)s.pop();else{const i=s.topOperatorState,a=t.at(i);!a.isExecutable||a.type===r.array?e.push(a):s.push(a)}}const ye="unknown";function Yt(s,e){var o,c,p;const{calls:t,operands:n}=s,i=s.memoryTracker;let a;if(t.topOperatorState===A){t.topOperatorState=m;const[h]=be(e.string,0,((o=e.debugSource)==null?void 0:o.filename)??ye);a=h}else{const[,h]=be(e.string,t.topOperatorState,((c=e.debugSource)==null?void 0:c.filename)??ye);a=h}if(!a)t.pop();else{const{pos:h}=a.debugSource;if(h>0&&(t.topOperatorState=h),((p=a.debugSource)==null?void 0:p.filename)===ye){const{debugSource:E,...g}=a;a=g}let f;if(a.type===r.string||a.type===r.name){f=j(a)[0];const E=i.addStringRef(f);if(!E.success){s.raiseException(E.exception);return}Object.assign(a,{tracker:i})}let k;a.isExecutable?k=t.push(a):k=n.push(a),f!==void 0&&i.releaseString(f),k.success||s.raiseException(k.exception)}}let qt=class it{constructor(e,t,n,i){d(this,"_memoryTracker");d(this,"_dictionaries");d(this,"_operands");d(this,"_calls");d(this,"_exception");d(this,"_exceptionStack");d(this,"_destroyed",!1);d(this,"_callDisablingCount",0);this._memoryTracker=e,this._dictionaries=t,this._operands=n,this._calls=i}static create(e={}){const t=new X({total:e.maxMemoryBytes,debug:e.debugMemory}),n=Bt.create(t,I,10,1);if(!n.success)return n;const i=n.value;e.hostDictionary&&i.setHost({type:r.dictionary,isReadOnly:!0,isExecutable:!1,dictionary:e.hostDictionary});const a=V.create(t,I,10);if(!a.success)return a;i.setGlobal(a.value.toValue({isReadOnly:!1})),a.value.release();const o=V.create(t,I,10);if(!o.success)return o;i.setUser(o.value.toValue({isReadOnly:!1})),o.value.release();const c=Oe.create(t,I,10,5);if(!c.success)return c;const p=W.create(t,I,10,5);return p.success?{success:!0,value:new it(t,i,c.value,p.value)}:p}get destroyed(){return this._destroyed}_checkIfDestroyed(){u(!this._destroyed,"State instance destroyed")}_resetException(){this._exception!==void 0&&(this._exception=void 0),this._exceptionStack!==void 0&&(this._exceptionStack.release(),this._exceptionStack=void 0)}get idle(){return this._checkIfDestroyed(),this._calls.length===0}get memoryTracker(){return this._memoryTracker}get operands(){return this._checkIfDestroyed(),this._operands}get dictionaries(){return this._checkIfDestroyed(),this._dictionaries}get callEnabled(){return this._callDisablingCount===0}get exception(){return this._checkIfDestroyed(),this._exception}get exceptionStack(){return this._checkIfDestroyed(),this._exceptionStack}exec(e){return this._checkIfDestroyed(),this.idle?(this._resetException(),this.calls.push(e),{success:!0,value:this.run()}):{success:!1,exception:"invalidAccess"}}destroy(){this._checkIfDestroyed(),this._resetException(),this._calls.release(),this._operands.release(),this._dictionaries.release(),this._destroyed=!0;const{used:e}=this._memoryTracker;u(e===0,"Memory leaks detected")}raiseException(e,t){if(this._resetException(),this._exception=e,t!==void 0)u(t instanceof W),this._exceptionStack=t,this._exceptionStack.addRef();else if(e!=="vmOverflow"){const n=this._calls.snapshot();u(n),this._exceptionStack=n.value}}clearException(){this._resetException()}get calls(){return this._calls}allowCall(){++this._callDisablingCount}preventCall(){--this._callDisablingCount}*run(){for(;this.calls.length!==0;)this.cycle(),yield}cycle(){const e=this._calls,{top:t}=e;this._exception?t.type===r.operator?nt(this,t):e.pop():t.isExecutable?t.type===r.operator?zt(this,t):t.type===r.name?Ut(this,t):t.type===r.array?Ft(this,t):t.type===r.string?Yt(this,t):u(!1,"Unsupported executable value"):(this._operands.push(t),e.pop())}};function Gt(s){return qt.create(s)}const O=3200,v=2e3,Ue=20,P=50,z=300,_=32,rt=500,jt=3;class Xt{constructor(){d(this,"_paddles",[{y:0,dy:0,score:0,running:!1},{y:0,dy:0,score:0,running:!1}]);d(this,"_ball",{x:0,dx:0,y:0,dy:0});this.reset()}get paddles(){return this._paddles}get ball(){return this._ball}resetPositions(){for(const t of this.paddles)t.y=Math.floor((v-z)/2),t.dy=0;const{ball:e}=this;e.x=Math.floor(O/2)-_,e.dx=0,e.y=Math.floor(v/2)-_,e.dy=0}reset(){this.resetPositions(),this.paddles[0].score=0,this.paddles[1].score=0}run(){for(const a of this._paddles){let{y:o,dy:c}=a;o+=c,c>0?o>v-z&&(o=2*(v-z)-o,c=-c):o<0&&(o=-o,c=-c),a.y=o,a.dy=c}let{x:e,dx:t,y:n,dy:i}=this._ball;e+=t,n+=i,e>O-_-P&&n>this._paddles[1].y&&n<this._paddles[1].y+z?(t=-t,e=2*(O-_-P)-e):e>O-_?(++this._paddles[0].score,t=-t,e=2*(O-_)-e):e<_+P&&n>this._paddles[0].y&&n<this._paddles[0].y+z?(t=-t,e=2*(_+P)-e):e<_&&(++this._paddles[1].score,t=-t,e=2*_-e),n>v-_?(i=-i,n=2*(v-_)-n):n<_&&(i=-i,n=2*_-n),this._ball={x:e,dx:t,y:n,dy:i}}}const Kt="board_width",Wt="board_height",Jt="paddle_width",Zt="paddle_height",Fe="current_y",me="current_x",Ye="opponent_y",ge="opponent_x",qe="ball_center_x",Ge="ball_center_y",Qt="ball_radius",je="ball_speed_x",Xe="ball_speed_y",Ke="paddle_up",We="paddle_down",T=s=>{const e=S(s);return u(e),e.value},Y=(s,e)=>({type:r.operator,isExecutable:!0,isReadOnly:!0,operator:{name:s,type:F.implementation,implementation:({operands:t})=>t.push(T(e()))}}),Je=(s,e)=>({type:r.operator,isExecutable:!0,isReadOnly:!0,operator:{name:s,type:F.implementation,implementation:e}});class es{constructor(e,t){d(this,"_mappings",{[Kt]:T(O),[Wt]:T(v),[Jt]:T(P),[Zt]:T(z),[me]:y,[Fe]:y,[ge]:y,[Ye]:y,[qe]:y,[Ge]:y,[Qt]:T(_),[je]:y,[Xe]:y,[Ke]:y,[We]:y});this._state=e,this._paddleIndex=t,this._paddleIndex===0?this._mappings[me]=T(0):this._mappings[me]=T(O-P),this._mappings[Fe]=Y("HOST_CURRENT_Y",()=>this._state.paddles[this._paddleIndex].y),this._paddleIndex===1?this._mappings[ge]=T(0):this._mappings[ge]=T(O-P),this._mappings[Ye]=Y("HOST_OPPONENT_Y",()=>this._state.paddles[1-this._paddleIndex].y),this._mappings[qe]=Y("HOST_BALL_CENTER_X",()=>this._state.ball.x),this._mappings[Ge]=Y("HOST_BALL_CENTER_Y",()=>this._state.ball.y),this._mappings[je]=Y("HOST_BALL_SPEED_X",()=>this._state.ball.dx),this._mappings[Xe]=Y("HOST_BALL_SPEED_Y",()=>this._state.ball.dy),this._mappings[Ke]=Je("HOST_PADDLE_UP",()=>{this._state.paddles[this._paddleIndex].dy=-1}),this._mappings[We]=Je("HOST_PADDLE_DOWN",()=>{this._state.paddles[this._paddleIndex].dy=1})}get names(){return Object.keys(this._mappings)}lookup(e){return this._mappings[e]??y}}class ts{constructor(){d(this,"_state");d(this,"_engines",[]);d(this,"_runners",[]);d(this,"_speed",1);d(this,"_ended",!1);this._state=new Xt}get state(){return this._state}_allocateEngine(e){const t=Gt({hostDictionary:new es(this._state,e)});u(t);const n=t.value;return this._engines[e]=n,n}get speed(){return this._speed}setup(){for(let e=0;e<2;++e){const t=this._allocateEngine(e),n=t.exec(G(`
/main
{
  {
    % Adjust pad position based on current position of the ball
    ball_center_y % ball position
    current_y paddle_height 2 div pop add % center of paddle
    lt
    {
      paddle_up
    }
    {
      paddle_down
    }
    ifelse
  } loop
} bind def
`,{isExecutable:!0}));u(n),[...n.value];const i=t.exec(G("main",{isExecutable:!0}));this._state.paddles[e].running=!0,u(i),this._runners[e]=i.value}}run(e){if(this._ended)return;let t=e*this._speed;for(;t-- >0;){this._state.run();for(let n=0;!this._ended&&n<2;++n){const i=this._state.paddles[n];if(i.score>=jt)this._ended=!0;else if(i.running){const{done:a}=this._runners[n].next();a&&(i.running=!1)}}}}}const w={width:0,height:0},U={width:0,height:0},K={radius:0},ss=s=>{throw new Error(`Unable to find '${s}'`)},H=s=>document.querySelector(s)??ss(s);let Se,Re,at,ot,ct;const _e=()=>{const e=window.innerWidth/window.innerHeight,t=O/v;e>t?(w.height=Math.max(window.innerHeight-2*50,v/Ue),w.width=Math.floor(w.height*t)):(w.width=Math.max(window.innerWidth-2*50,O/Ue),w.height=Math.floor(w.width/t)),U.width=Math.ceil(P*w.width/O),U.height=Math.ceil(z*w.height/v),K.radius=Math.ceil(_*w.height/v),at.setAttribute("style",`width: ${w.width}px; height: ${w.height}px`)};let ie,te;const ns=s=>{document.body.innerHTML=`
    <div class="status"></div>
    <div class="board">
      <div class="paddle_1 paddle"></div>
      <div class="score_1 score">0</div>
      <div class="paddle_2 paddle"></div>
      <div class="score_2 score">0</div>
      <div class='ball'>
        <div class="ball_effect"></div>
      </div>
    </div>
  `,Se=[H(".paddle_1"),H(".paddle_2")],Re=[H(".score_1"),H(".score_2")],at=H(".board"),ot=H(".ball"),ct=H(".status"),window.addEventListener("resize",_e),window.addEventListener("load",_e),_e(),ie=0,te=rt,requestAnimationFrame(e=>{ie=e,requestAnimationFrame(ut.bind(s))})},ut=function(s){const{state:e,speed:t}=this,n=s-ie;ie=s;const i=Math.floor(1e3/n);te-=n,te<=0&&(ct.innerHTML=`x${t} fps: ${i}/s`,te=rt),Se[0].setAttribute("style",`width: ${U.width}px; height: ${U.height}px; top: ${100*(e.paddles[0].y/v)}%;`),Re[0].innerHTML=e.paddles[0].score.toString(),Se[1].setAttribute("style",`width: ${U.width}px; height: ${U.height}px; left: calc(100% - ${U.width}px); top: ${100*(e.paddles[1].y/v)}%;`),Re[1].innerHTML=e.paddles[1].score.toString(),ot.setAttribute("style",`width: ${K.radius*2}px; height: ${K.radius*2}px; left: calc(${100*(e.ball.x/O)}% - ${K.radius}px); top: calc(${100*(e.ball.y/v)}% - ${K.radius}px)`),setTimeout(()=>{this.run(Math.ceil(n/4)),requestAnimationFrame(ut.bind(this))},0)},lt=new ts;lt.setup();ns(lt);
